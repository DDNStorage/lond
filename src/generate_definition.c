/*
 * Copyright (c) 2019, DDN Storage Corporation.
 */
/*
 *
 * Generate the definition for Python library
 *
 * Author: Li Xi <lixi@ddn.com>
 */
#include <unistd.h>
#include <getopt.h>
#include "debug.h"
#include "definition.h"

static void usage(char *prog)
{
	fprintf(stderr,
		"Usage: %s <path-to-definition.py>\n",
		prog);
}

int main(int argc, char **argv)
{
	FILE *fp;
	char *path;
	struct option *option;
	struct option fetch_long_opts[] = FETCH_LONG_OPTIONS;
	const char *head = ("# Please DO NOT edit this file directly!\n"
			    "# File generated by generate_definition command\n"
			    "# Copyright (c) 2019 DataDirect Networks, Inc.\n"
			    "# All Rights Reserved.\n"
			    "# Author: lixi@ddn.com\n"
			    "\n"
			    "\"\"\"\n"
			    "Constants that should be synced with C language codes\n"
			    "\"\"\"\n\n"
			    "from pylond import definition_helper\n\n");
	char buffer[1024];
	char *short_opt;
	char *has_arg;

	if (argc != 2) {
		usage(argv[0]);
		return 1;
	}

	path = argv[1];

	fp = fopen(path, "w");
	if (fp == NULL) {
		LERROR("failed to open file [%s]\n", path);
		return -1;
	}

	fprintf(fp, "%s", head);
	fprintf(fp,
		"LOND_FETCH_OPTIONS = definition_helper.CommandOptions()\n");
	option = fetch_long_opts;
	while (option < fetch_long_opts + ARRAY_SIZE(fetch_long_opts) &&
	       option->name != NULL) {
		/* hide the option */
		if (option->val == OPT_PROGNAME) {
			option++;
			continue;
		}
		LERROR("option: %s\n", option->name);

		if ((option->val >= 'a' && option->val <= 'x') ||
		    (option->val >= 'A' && option->val <= 'X')) {
			buffer[0] = '\'';
			buffer[1] = option->val;
			buffer[2] = '\'';
			buffer[3] = '\0';
			short_opt = buffer;
		} else {
			short_opt = "None";
		}
		if (option->has_arg)
			has_arg = "True";
		else
			has_arg = "False";
		fprintf(fp,
			"OPTION = definition_helper.CommandOption('%s', %s, short_opt=%s)\n",
			option->name, has_arg, short_opt);
		fprintf(fp, "LOND_FETCH_OPTIONS.cos_add_option(OPTION)\n");
		option++;
	}
	fprintf(fp,
		"LOND_FETCH_OPTIONS.cos_add_argument(definition_helper.CommandArgument(is_dir_path=True))\n"
		);

	fprintf(fp, "LOND_OPTION_PROGNAME = '%s'\n", LOND_OPTION_PROGNAME);

	fclose(fp);

	return 0;
}
